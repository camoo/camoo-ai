<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>EpiNett AI Chat</title>
    <style>
        body { font-family: system-ui, sans-serif; background:#fafafa; margin:0; padding:0; }
        #chat-box { height:80vh; overflow-y:auto; padding:1rem; background:#f1f1f1; }
        .msg { margin:0.4rem 0; padding:0.6rem 0.8rem; border-radius:0.5rem; max-width:70%; white-space:pre-wrap; }
        .user { background:#007bff; color:#fff; margin-left:auto; text-align:right; }
        .bot { background:#fff; border:1px solid #ccc; color:#000; }
        form { display:flex; padding:0.5rem; background:#fff; }
        input { flex:1; padding:0.5rem; font-size:1rem; }
        button { padding:0.5rem 1rem; background:#007bff; color:#fff; border:none; cursor:pointer; }
    </style>
</head>
<body>
<div id="chat-box"></div>
<form id="chat-form">
    <input id="msg" type="text" placeholder="Type your message..." autocomplete="off" />
    <button>Send</button>
</form>

<script>
    const chat = document.getElementById('chat-box');
    const form = document.getElementById('chat-form');
    const input = document.getElementById('msg');
    let sessionId = localStorage.getItem('epinett_session_id') || null;

    function appendMessage(text, role = 'bot') {
        const div = document.createElement('div');
        div.className = 'msg ' + role;
        div.textContent = text;
        chat.appendChild(div);
        chat.scrollTop = chat.scrollHeight;
        return div;
    }

    async function send(msg) {
        if (!msg.trim()) return;
        appendMessage(msg, 'user');
        input.value = '';

        const fd = new FormData();
        fd.append('message', msg);
        if (sessionId) fd.append('sessionId', sessionId);

        const res = await fetch('/ai/chat', { method: 'POST', body: fd });
        const reader = res.body.getReader();
        const decoder = new TextDecoder();

        let buffer = '';
        let currentDiv = null;

        while (true) {
            const { done, value } = await reader.read();
            if (done) {
                // Process any remaining complete JSON objects in buffer
                processBuffer(true);
                break;
            }

            buffer += decoder.decode(value, { stream: true });
            processBuffer(false);
        }

        function processBuffer(force = false) {
            // Match any complete `data: { ... }` occurrences (requires the closing brace)
            const re = /data:\s*({[\s\S]*?})/g;
            let match;
            let lastProcessed = 0;

            while ((match = re.exec(buffer)) !== null) {
                const jsonStr = match[1];
                try {
                    const data = JSON.parse(jsonStr);

                    // Handle chunk
                    if (data.type === 'chunk') {
                        if (!currentDiv) currentDiv = appendMessage('', 'bot');
                        // Append without losing previous content
                        appendChunkText(currentDiv, data.text);
                        chat.scrollTop = chat.scrollHeight;
                    }

                    if (data.type === 'done') {
                        if (data.sessionId) {
                            sessionId = data.sessionId;
                            localStorage.setItem('epinett_session_id', sessionId);
                        }
                        currentDiv = null;
                    }

                    if (data.type === 'error') {
                        appendMessage('❌ ' + data.text, 'bot');
                        currentDiv = null;
                    }

                    lastProcessed = re.lastIndex;
                } catch (e) {
                    // If parse fails, stop processing further matches (incomplete JSON)
                    // Ensure regex doesn't loop infinitely
                    break;
                }
            }

            // If we've processed something, drop that part from the buffer
            if (lastProcessed > 0) {
                buffer = buffer.slice(lastProcessed);
            } else if (force) {
                // If forcing (stream closed), try to extract any remaining `data:` lines that might be simple (e.g., plain text)
                const lines = buffer.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
                for (const line of lines) {
                    if (line.startsWith('data:')) {
                        const payload = line.slice(5).trim();
                        try {
                            const data = JSON.parse(payload);
                            if (data.type === 'chunk') {
                                if (!currentDiv) currentDiv = appendMessage('', 'bot');
                                appendChunkText(currentDiv, data.text);
                            } else if (data.type === 'done') {
                                if (data.sessionId) {
                                    sessionId = data.sessionId;
                                    localStorage.setItem('epinett_session_id', sessionId);
                                }
                                currentDiv = null;
                            } else if (data.type === 'error') {
                                appendMessage('❌ ' + data.text, 'bot');
                                currentDiv = null;
                            }
                        } catch (e) {
                            // ignore non-JSON leftover
                        }
                    }
                }
                buffer = '';
            }
        }
    }

    form.addEventListener('submit', e => {
        e.preventDefault();
        send(input.value);
    });

    appendMessage('👋 Hello! I am EpiNett. Type something to start chatting.');
    // helper: append a chunk to a message div, inserting one space only when needed
    function appendChunkText(div, text) {
        if (!div || !text) return;
        const prev = div.textContent || '';
        // if previous text ends with whitespace or new chunk starts with whitespace, append as-is
        if (/\s$/.test(prev) || /^\s/.test(text)) {
            div.textContent += text;
        } else {
            // otherwise insert a single space between chunks
            div.textContent += (prev ? ' ' : '') + text;
        }
    }


</script>


</body>
</html>
